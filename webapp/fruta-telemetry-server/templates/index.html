<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>FRUTA Telemetry Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <style>
    /* Light and dark theme variables */
    :root{
      --bg:#f3f6fb; --card:#fff; --muted:#6b7280; --accent:#0ea5a4; --accent-600:#089189; --text:#0f172a;
      font-family: "Segoe UI", Roboto, Arial, sans-serif;
    }
    /* Dark theme overrides */
    .dark {
      --bg: #0b1220;
      --card: #0f1724;
      --muted: #94a3b8;
      --accent: #34d399;
      --accent-600: #10b981;
      --text: #e6eef6;
    }

    /* Layout & components */
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text)}
    .wrap{max-width:1100px;margin:24px auto;padding:18px}
    header{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;margin-bottom:14px}
    header h1{margin:0;font-size:20px}
    header p{margin:0;color:var(--muted);font-size:13px}
    .controls-row{display:flex;gap:10px;align-items:center}
    .card{background:var(--card);border-radius:10px;box-shadow:0 8px 24px rgba(15,23,42,0.06);padding:14px;color:var(--text)}
    .top-grid{display:grid;grid-template-columns: 1fr 380px; gap:14px}
    .viewer{min-height:360px;border-radius:10px;overflow:hidden;display:flex;flex-direction:column}
    .viewer .imgwrap{flex:1;background:linear-gradient(180deg,#eef6f9,#fff);display:flex;align-items:center;justify-content:center;border-radius:8px;padding:12px}
    .dark .viewer .imgwrap{background:linear-gradient(180deg,#071018,#0b1220)}
    .viewer img{max-width:100%;max-height:100%;object-fit:contain;border-radius:8px;box-shadow:0 6px 16px rgba(15,23,42,0.06)}
    .side-list{height:360px;overflow:auto;padding:10px;border-radius:8px;border:1px solid #eef4f6;background:#fbfcfd}
    .dark .side-list{border:1px solid rgba(255,255,255,0.04);background:transparent}
    .list-item{padding:10px;border-radius:8px;border-bottom:1px dashed #eef2f3;cursor:pointer}
    .list-item:last-child{border-bottom:0}
    .list-item:hover{background:#f0fbfa}
    .time{font-size:12px;color:var(--muted)}
    .badge{padding:4px 8px;background:var(--accent);color:#fff;border-radius:999px;font-weight:700;font-size:12px;margin-left:8px}
    .chart-area{margin-top:16px;padding:14px;border-radius:10px}
    .controls{display:flex;gap:10px;flex-wrap:wrap}
    input,select,textarea{padding:8px 10px;border-radius:8px;border:1px solid #e6e9ef;background:transparent;color:var(--text);box-sizing:border-box;max-width:100%}
    .dark input, .dark select, .dark textarea{border:1px solid rgba(255,255,255,0.06)}
    button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer}
    .muted{color:var(--muted);font-size:13px}
    @media(max-width:980px){
      .top-grid{grid-template-columns:1fr}
      .side-list{height:auto}
      .viewer{min-height:260px}
    }

    /* Settings overlay specific styles: prevent overflow and text overlap */
    #settingsOverlay{z-index:9999}
    #settingsOverlay .card{width:720px;margin:auto;max-height:80vh;overflow:auto;padding:16px;box-sizing:border-box}
    #settingsOverlay input[type="url"], #settingsOverlay input[type="text"], #settingsOverlay input[type="password"]{
      width:100%; min-width:0; word-break:break-all;
    }
    /* ensure long tokens wrap and don't overflow the box */
    #settingsOverlay input { white-space:normal; overflow-wrap: anywhere; }

    /* Small icon-style theme toggle */
    #themeToggle{background:transparent;color:var(--accent);border:1px solid #e6e9ef;padding:6px;border-radius:8px;cursor:pointer}
    .dark #themeToggle{border:1px solid rgba(255,255,255,0.06); color:var(--accent)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>FRUTA Telemetry Viewer</h1>
        <p class="muted">Latest photo, detections and telemetry ‚Äî click a row to load that image.</p>
      </div>
      <div class="controls-row">
        <button id="go">Load latest</button>
        <button id="autoRefreshToggle" title="Toggle auto refresh" style="background:transparent;color:var(--accent);border:1px solid #e6e9ef;padding:6px;border-radius:8px;cursor:pointer">Auto refresh: Off</button>
        <button id="themeToggle" title="Toggle theme">üåô</button>
        <button id="settingsBtn" title="Settings" style="background:transparent;color:var(--accent);border:1px solid #e6e9ef;padding:6px;border-radius:8px;">‚öôÔ∏è</button>
        <!-- Hidden inputs: values are edited through settings panel and persisted to localStorage -->
        <input id="containerUrl" type="url" placeholder="https://account.blob.core.windows.net/container?sv=..." style="display:none;width:420px"/>
        <input id="sas" type="text" placeholder="?sv=... (optional if included in URL)" style="display:none;width:360px"/>
      </div>
    </header>

    <div class="card">
      <div class="top-grid">
        <div class="viewer">
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
            <div class="muted">Most recent photo / video</div>
            <div style="display:flex;gap:8px;align-items:center">
              <div id="detectionBadge" class="badge" style="display:none">MANGO</div>
              <div id="photoInfo" class="muted"></div>
            </div>
          </div>
          <div class="imgwrap" id="imgwrap">
            <div class="muted">No image loaded</div>
          </div>
        </div>

        <div>
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div class="muted">Timestamps & messages</div>
            <div><button id="analyzeSelected" disabled>Analyze (vision)</button></div>
          </div>
          <div class="side-list" id="list"></div>
        </div>
      </div>

      <div class="chart-area">
        <canvas id="trendChart" height="140"></canvas>
      </div>
    </div>
  </div>

  <!-- Settings overlay (hidden by default) -->
  <div id="settingsOverlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);align-items:center;justify-content:center;">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div><strong>Settings</strong><div class="muted">Paste your container URL or SAS token here ‚Äî values are saved locally.</div></div>
        <div><button id="closeSettings">Close</button></div>
      </div>
      <div style="display:flex;gap:8px;flex-direction:column;">
        <label class="muted">Container URL (optional, include SAS if you want)</label>
        <input id="settingsContainerUrl" type="url" style="width:100%" />
        <label class="muted">SAS token (optional, if not in URL)</label>
        <input id="settingsSas" type="text" style="width:100%" />
        <label class="muted">API Ninjas Key (will be stored on server, not in your browser)</label>
        <input id="settingsApiKey" type="password" style="width:100%" placeholder="Paste API key to save on server" />
        <label class="muted">Container/account defaults (optional)</label>
        <div style="display:flex;gap:8px;">
          <input id="settingsAccount" placeholder="account name (e.g. frutablob)" style="flex:1"/>
          <input id="settingsContainer" placeholder="container name (e.g. fruta-container2)" style="flex:1"/>
        </div>
        <div style="display:flex;justify-content:flex-end;margin-top:8px">
          <button id="saveSettings">Save</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script>
    // apply persisted theme preference on load
    (function(){
      try {
        const dark = JSON.parse(localStorage.getItem('fruta.dark') || 'false');
        if(dark) document.documentElement.classList.add('dark');
        document.getElementById('themeToggle').textContent = dark ? '‚òÄÔ∏è' : 'üåô';
      } catch(e){}
    })();

    // toggle theme and persist choice
    document.getElementById('themeToggle').addEventListener('click', ()=>{
      const isDark = document.documentElement.classList.toggle('dark');
      document.getElementById('themeToggle').textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
      localStorage.setItem('fruta.dark', JSON.stringify(isDark));
    });

    // defaults (can be overridden via Settings and saved in localStorage)
    const accountEl = { account: 'frutablob', container: 'fruta-container2' };
    // Auto-refresh / polling configuration with exponential backoff
    let autoRefresh = false;
    let pollHandle = null;
    let currentPollMs = 5000;          // start at 5s for faster updates
    const basePollMs = 5000;
    const maxPollMs = 60000;           // backoff ceiling 60s
    const backoffFactor = 1.8;
    let failureCount = 0;

    // last-seen markers (prefer ETag)
    let lastSeenName = null;
    let lastSeenEtag = null;
    let lastSeenLastModified = null;

    // SSE client
    let evtSource = null;
    let sseReconnectMs = 1000;
    const sseMaxReconnectMs = 30000;
    function startSSE(){
      if(typeof EventSource === 'undefined') return false;
      if(evtSource) return true;
      try {
        evtSource = new EventSource('/events');
        evtSource.onopen = ()=> { console.info('SSE open'); sseReconnectMs = 1000; };
        evtSource.onmessage = (ev)=>{
          try {
            const msg = JSON.parse(ev.data);
            // expected message structure: { type: 'blob', name, etag, lastModified } or { type: 'list', items: [...] }
            if(msg.type === 'blob'){
              // If a new blob arrived, trigger immediate update
              if(msg.etag && msg.etag !== lastSeenEtag || (!msg.etag && msg.lastModified !== lastSeenLastModified) || msg.name !== lastSeenName){
                console.info('SSE: new blob event', msg);
                // ensure list+viewer are updated
                awaitLoadLatest();
              }
            } else if(msg.type === 'list' && Array.isArray(msg.items)){
              // server can push full list -> render and maybe load newest
              handleServerList(msg.items);
            }
          } catch(e){ console.warn('SSE parse error', e); }
        };
        evtSource.onerror = (e)=>{
          console.warn('SSE error', e);
          // close and schedule reconnect
          try { evtSource.close(); } catch(_) {}
          evtSource = null;
          setTimeout(()=> { sseReconnectMs = Math.min(sseMaxReconnectMs, sseReconnectMs * 1.5); startSSE(); }, sseReconnectMs);
        };
        return true;
      } catch(e){
        console.warn('SSE not available', e);
        evtSource = null;
        return false;
      }
    }

    function stopSSE(){
      if(evtSource){ try{ evtSource.close(); }catch(_){} evtSource = null; }
    }

    function handleServerList(items){
      // items expected: [{ name, etag, lastModified }, ...] newest first
      if(!items || items.length === 0) return;
      const newest = items[0];
      if(newest.etag) {
        if(newest.etag !== lastSeenEtag) { lastSeenEtag = newest.etag; lastSeenName = newest.name; lastSeenLastModified = newest.lastModified; awaitLoadLatest(); }
      } else if(newest.lastModified){
        if(newest.lastModified !== lastSeenLastModified) { lastSeenLastModified = newest.lastModified; lastSeenName = newest.name; awaitLoadLatest(); }
      } else {
        // fallback by name
        if(newest.name !== lastSeenName) { lastSeenName = newest.name; awaitLoadLatest(); }
      }
    }

    // helper to call loadLatest but avoid overlapping calls
    let pendingLoad = false;
    async function awaitLoadLatest(){
      if(pendingLoad) return;
      pendingLoad = true;
      try { await loadLatest(); } catch(e){ console.warn('awaitLoadLatest err', e); }
      pendingLoad = false;
    }

    function toggleAutoRefresh(on) {
      autoRefresh = typeof on === 'boolean' ? on : !autoRefresh;
      const btn = document.getElementById('autoRefreshToggle');
      btn.textContent = `Auto refresh: ${autoRefresh ? 'On' : 'Off'}`;
      if (autoRefresh) {
        // try SSE first; if not available, start polling
        const sseOk = startSSE();
        if(!sseOk) startPolling();
      } else {
        stopPolling();
        stopSSE();
      }
    }

    function startPolling(){
      stopPolling();
      // use a self-scheduling loop so we can change next interval based on success/failure
      const loop = async ()=>{
        if(!autoRefresh) return;
        try {
          const containerUrl = document.getElementById('containerUrl').value.trim() || null;
          const sas = document.getElementById('sas').value.trim();
          const items = await listBlobs(accountEl.account, accountEl.container, sas, containerUrl);
          if(items && items.length){
            const newest = items[0];
            // prefer ETag if present
            const newestEtag = newest.etag || null;
            const newestLM = newest.lastModified || null;
            const changed = (newestEtag && newestEtag !== lastSeenEtag) ||
                            (!newestEtag && newestLM && newestLM !== lastSeenLastModified) ||
                            (newest.name && newest.name !== lastSeenName && !newestEtag && !newestLM);
            if(changed){
              lastSeenEtag = newestEtag; lastSeenLastModified = newestLM; lastSeenName = newest.name;
              currentItems = items;
              renderList(items);
              await loadItem(0);
            } else {
              // update list UI (timestamps) without reloading image
              currentItems = items;
              renderList(items);
            }
          }
          // success => reduce backoff
          failureCount = 0;
          currentPollMs = basePollMs;
        } catch(e){
          console.warn('Polling error', e);
          failureCount++;
          currentPollMs = Math.min(maxPollMs, Math.max(basePollMs, currentPollMs * backoffFactor));
        } finally {
          // schedule next iteration only if autoRefresh still true and SSE not active
          if(autoRefresh && !evtSource) pollHandle = setTimeout(loop, currentPollMs);
        }
      };
      // start immediately
      loop();
    }

    function stopPolling(){
      if(pollHandle) { clearTimeout(pollHandle); pollHandle = null; }
    }

    // ---- Application state & helper functions ----
    let currentItems = [];       // last loaded list from server
    let currentIndex = null;     // currently displayed index

    // load saved settings from localStorage and populate hidden inputs
    function loadSavedSettings(){
      const s = JSON.parse(localStorage.getItem('fruta.settings') || '{}');
      if(s.containerUrl) document.getElementById('containerUrl').value = s.containerUrl;
      if(s.sas) document.getElementById('sas').value = s.sas;
      if(s.account) accountEl.account = s.account;
      if(s.container) accountEl.container = s.container;

      // settings overlay fields
      document.getElementById('settingsContainerUrl').value = s.containerUrl || '';
      document.getElementById('settingsSas').value = s.sas || '';
      document.getElementById('settingsAccount').value = s.account || accountEl.account;
      document.getElementById('settingsContainer').value = s.container || accountEl.container;
    }

    function openSettings(){
      document.getElementById('settingsOverlay').style.display = 'flex';
    }
    function closeSettings(){
      document.getElementById('settingsOverlay').style.display = 'none';
    }

    document.getElementById('settingsBtn').addEventListener('click', openSettings);
    document.getElementById('closeSettings').addEventListener('click', closeSettings);
    document.getElementById('saveSettings').addEventListener('click', async ()=>{
      const settings = {
        containerUrl: document.getElementById('settingsContainerUrl').value.trim() || '',
        sas: document.getElementById('settingsSas').value.trim() || '',
        account: document.getElementById('settingsAccount').value.trim() || accountEl.account,
        container: document.getElementById('settingsContainer').value.trim() || accountEl.container,
      };

      // Send API key to server for secure storage (if user provided one)
      const apiKey = document.getElementById('settingsApiKey').value.trim();
      try {
        if(apiKey) {
          // POST apiKey and optional container/account to server; server stores key in app.config (volatile)
          await fetch('/api/settings', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ apiKey, accountName: settings.account, containerName: settings.container, sas: settings.sas, containerUrl: settings.containerUrl })
          });
          // Clear API input after sending for safety (it is not stored in localStorage)
          document.getElementById('settingsApiKey').value = '';
        } else {
          // If no apiKey, still post other non-secret settings (optional)
          await fetch('/api/settings', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ accountName: settings.account, containerName: settings.container, sas: settings.sas, containerUrl: settings.containerUrl })
          });
        }
      } catch(err){ console.warn('Failed to save server settings', err); }

      // Persist client-only settings locally (do NOT store API key)
      localStorage.setItem('fruta.settings', JSON.stringify(settings));
      loadSavedSettings();
      closeSettings();
    });

    document.getElementById('go').addEventListener('click', ()=> awaitLoadLatest());
    document.getElementById('analyzeSelected').addEventListener('click', analyzeCurrent);

    // initial load
    loadSavedSettings();

    // restore previous state (do not start polling unless it was ON)
    try {
      const wasOn = JSON.parse(localStorage.getItem('fruta.autoRefresh') || 'false');
      if(wasOn) toggleAutoRefresh(true);
      else {
        // ensure button label matches Off state
        document.getElementById('autoRefreshToggle').textContent = 'Auto refresh: Off';
      }
    } catch(e){ /* ignore malformed storage */ }

    // ---- Networking helpers (talk to our Flask API) ----

    // listBlobs: call backend /api/load_latest and return items array
    async function listBlobs(accountName, containerName, sas, containerUrl){
      // prefer explicit containerUrl if supplied (client-side)
      const params = new URLSearchParams();
      if(containerUrl) params.set('containerUrl', containerUrl);
      if(sas) params.set('sas', sas);
      // backend uses env/app.config if not provided
      const url = '/api/load_latest' + (params.toString() ? ('?' + params.toString()) : '');
      const r = await fetch(url, { method: 'GET' });
      if(!r.ok) {
        const txt = await r.text().catch(()=>null);
        throw new Error('load_latest failed: ' + (txt || r.status));
      }
      const j = await r.json();
      return j.items || [];
    }

    // fetchBlobMetadata: call backend /api/fetch_blob?name=...
    async function fetchBlobMetadata(name){
      const params = new URLSearchParams();
      const containerUrl = document.getElementById('containerUrl').value.trim();
      const sas = document.getElementById('sas').value.trim();
      if(containerUrl) params.set('containerUrl', containerUrl);
      if(sas) params.set('sas', sas);
      params.set('name', name);
      const url = '/api/fetch_blob?' + params.toString();
      const r = await fetch(url);
      if(!r.ok) throw new Error('fetch_blob failed');
      return r.json();
    }

    // loadLatest: fetch list, render, and load newest item if present
    async function loadLatest(){
      const containerUrl = document.getElementById('containerUrl').value.trim() || null;
      const sas = document.getElementById('sas').value.trim();
      const items = await listBlobs(accountEl.account, accountEl.container, sas, containerUrl);
      currentItems = items;
      renderList(items);
      if(items && items.length) {
        await loadItem(0);
      } else {
        // clear viewer
        currentIndex = null;
        document.getElementById('imgwrap').innerHTML = '<div class="muted">No image loaded</div>';
        document.getElementById('photoInfo').textContent = '';
        document.getElementById('analyzeSelected').disabled = true;
        document.getElementById('detectionBadge').style.display = 'none';
      }
    }

    // renderList: populate right-hand list; clicking an item loads it
    function renderList(items){
      const listEl = document.getElementById('list');
      listEl.innerHTML = '';
      items.forEach((it, idx)=>{
        const el = document.createElement('div');
        el.className = 'list-item';
        el.dataset.index = idx;
        const name = it.name || '(unknown)';
        const time = it.lastModified ? new Date(it.lastModified).toLocaleString() : '';
        el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:600">${escapeHtml(name)}</div><div class="time">${escapeHtml(time)}</div></div>`;
        el.addEventListener('click', ()=> loadItem(idx));
        listEl.appendChild(el);
      });
    }

    // loadItem: display image for item at index (uses item's url if available, otherwise fetch metadata)
    async function loadItem(index){
      if(!currentItems || index < 0 || index >= currentItems.length) return;
      currentIndex = index;
      const it = currentItems[index];
      let blobUrl = it.url || null;
      if(!blobUrl) {
        // resolve via backend
        try {
          const meta = await fetchBlobMetadata(it.name);
          blobUrl = meta.blob_url || meta.blobUrl || null;
        } catch(e){
          console.warn('failed to fetch blob metadata', e);
        }
      }
      // render image element
      const wrap = document.getElementById('imgwrap');
      wrap.innerHTML = '<div class="muted">Loading image‚Ä¶</div>';
      if(!blobUrl){
        wrap.innerHTML = '<div class="muted">Image URL not available</div>';
        document.getElementById('analyzeSelected').disabled = true;
        return;
      }
      // create image element (use fetch to ensure CORS & SAS work)
      const img = document.createElement('img');
      img.alt = it.name || '';
      img.onload = ()=> { /* loaded */ };
      img.onerror = ()=> { wrap.innerHTML = '<div class="muted">Failed to load image</div>'; };
      img.src = blobUrl;
      wrap.innerHTML = '';
      wrap.appendChild(img);

      // update info and controls
      document.getElementById('photoInfo').textContent = `${it.name || ''} ${it.lastModified ? ' ¬∑ ' + new Date(it.lastModified).toLocaleString() : ''}`;
      document.getElementById('analyzeSelected').disabled = false;
      // hide badge until analysis runs
      document.getElementById('detectionBadge').style.display = 'none';
    }

    // analyzeCurrent: call /api/analyze for current item and display results
    async function analyzeCurrent(){
      if(currentIndex === null || !currentItems[currentIndex]) return;
      const it = currentItems[currentIndex];
      // prefer blob url if present
      const payload = {};
      if(it.url) payload.blobUrl = it.url;
      else payload.blobName = it.name;

      // include client-side containerUrl/sas if configured so server can resolve correctly
      const containerUrl = document.getElementById('containerUrl').value.trim();
      const sas = document.getElementById('sas').value.trim();
      if(containerUrl) payload.containerUrl = containerUrl;
      if(sas) payload.sas = sas;

      // disable button while analyzing
      const btn = document.getElementById('analyzeSelected');
      btn.disabled = true;
      btn.textContent = 'Analyzing‚Ä¶';
      try {
        const r = await fetch('/api/analyze', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify(payload)
        });
        const j = await r.json();
        if(!r.ok){
          console.warn('analyze error', j);
          alert('Analyze failed: ' + (j.error || r.status));
        } else {
          // show mango likelihood and detections
          const likelihood = j.mango_likelihood || 0;
          const badge = document.getElementById('detectionBadge');
          if(likelihood > 0.3){
            badge.style.display = 'inline-block';
            badge.textContent = `MANGO ${(likelihood*100).toFixed(0)}%`;
          } else {
            badge.style.display = 'none';
          }
          // optional: show detections in console or small popup
          console.info('Detections', j.detections || []);
          // update chart data (simple increment)
          pushTrendData(likelihood);
        }
      } catch(e){
        console.warn('analyze request failed', e);
        alert('Analyze request failed');
      } finally {
        btn.disabled = false;
        btn.textContent = 'Analyze (vision)';
      }
    }

    // small utility: escape HTML to avoid injection in list
    function escapeHtml(s){
      return String(s||'').replace(/[&<>"']/g, (m)=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]) );
    }

    // ---- simple trend chart to show mango likelihood over time ----
    const ctx = document.getElementById('trendChart').getContext('2d');
    const trendData = { labels: [], datasets: [{ label: 'Mango likelihood', data: [], borderColor: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#0ea5a4', tension:0.3 }] };
    const trendChart = new Chart(ctx, { type: 'line', data: trendData, options: { responsive:true, maintainAspectRatio:false, scales:{ y:{ min:0, max:1 } } } });
    function pushTrendData(value){
      const label = new Date().toLocaleTimeString();
      trendData.labels.push(label);
      trendData.datasets[0].data.push(Number(value || 0));
      if(trendData.labels.length > 20){ trendData.labels.shift(); trendData.datasets[0].data.shift(); }
      trendChart.update();
    }

    // Expose a simple keyboard shortcut: L = load latest, A = analyze
    document.addEventListener('keydown', (e)=>{
      if(e.key === 'L' || e.key === 'l') awaitLoadLatest();
      if((e.key === 'A' || e.key === 'a') && !document.getElementById('analyzeSelected').disabled) analyzeCurrent();
    });

    // initial action: attempt to load latest on first open
    awaitLoadLatest();
  </script>
</body>
</html>