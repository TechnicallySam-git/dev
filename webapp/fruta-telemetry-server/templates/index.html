<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>FRUTA Telemetry Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <style>
    /* Light and dark theme variables */
    :root{
      --bg:#f3f6fb; --card:#fff; --muted:#6b7280; --accent:#0ea5a4; --accent-600:#089189; --text:#0f172a;
      font-family: "Segoe UI", Roboto, Arial, sans-serif;
    }
    /* Dark theme overrides */
    .dark {
      --bg: #0b1220;
      --card: #0f1724;
      --muted: #94a3b8;
      --accent: #34d399;
      --accent-600: #10b981;
      --text: #e6eef6;
    }

    /* Layout & components */
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text)}
    .wrap{max-width:1100px;margin:24px auto;padding:18px}
    header{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;margin-bottom:14px}
    header h1{margin:0;font-size:20px}
    header p{margin:0;color:var(--muted);font-size:13px}
    .controls-row{display:flex;gap:10px;align-items:center}
    .card{background:var(--card);border-radius:10px;box-shadow:0 8px 24px rgba(15,23,42,0.06);padding:14px;color:var(--text)}
    .top-grid{display:grid;grid-template-columns: 1fr 380px; gap:14px}
    .viewer{min-height:360px;border-radius:10px;overflow:hidden;display:flex;flex-direction:column}
    .viewer .imgwrap{flex:1;background:linear-gradient(180deg,#eef6f9,#fff);display:flex;align-items:center;justify-content:center;border-radius:8px;padding:12px}
    .dark .viewer .imgwrap{background:linear-gradient(180deg,#071018,#0b1220)}
    .viewer img{max-width:100%;max-height:100%;object-fit:contain;border-radius:8px;box-shadow:0 6px 16px rgba(15,23,42,0.06)}
    .side-list{height:360px;overflow:auto;padding:10px;border-radius:8px;border:1px solid #eef4f6;background:#fbfcfd}
    .dark .side-list{border:1px solid rgba(255,255,255,0.04);background:transparent}
    .list-item{padding:10px;border-radius:8px;border-bottom:1px dashed #eef2f3;cursor:pointer}
    .list-item:last-child{border-bottom:0}
    .list-item:hover{background:#f0fbfa}
    .time{font-size:12px;color:var(--muted)}
    .badge{padding:4px 8px;background:var(--accent);color:#fff;border-radius:999px;font-weight:700;font-size:12px;margin-left:8px}
    .chart-area{margin-top:16px;padding:14px;border-radius:10px}
    .controls{display:flex;gap:10px;flex-wrap:wrap}
    input,select,textarea{padding:8px 10px;border-radius:8px;border:1px solid #e6e9ef;background:transparent;color:var(--text);box-sizing:border-box;max-width:100%}
    .dark input, .dark select, .dark textarea{border:1px solid rgba(255,255,255,0.06)}
    button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer}
    .muted{color:var(--muted);font-size:13px}
    @media(max-width:980px){
      .top-grid{grid-template-columns:1fr}
      .side-list{height:auto}
      .viewer{min-height:260px}
    }

    /* Settings overlay specific styles: prevent overflow and text overlap */
    #settingsOverlay{z-index:9999}
    #settingsOverlay .card{width:720px;margin:auto;max-height:80vh;overflow:auto;padding:16px;box-sizing:border-box}
    #settingsOverlay input[type="url"], #settingsOverlay input[type="text"], #settingsOverlay input[type="password"]{
      width:100%; min-width:0; word-break:break-all;
    }
    /* ensure long tokens wrap and don't overflow the box */
    #settingsOverlay input { white-space:normal; overflow-wrap: anywhere; }

    /* Small icon-style theme toggle */
    #themeToggle{background:transparent;color:var(--accent);border:1px solid #e6e9ef;padding:6px;border-radius:8px;cursor:pointer}
    .dark #themeToggle{border:1px solid rgba(255,255,255,0.06); color:var(--accent)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>FRUTA Telemetry Viewer</h1>
        <p class="muted">Latest photo, detections and telemetry ‚Äî click a row to load that image.</p>
      </div>
      <div class="controls-row">
        <button id="go">Load latest</button>
        <button id="autoRefreshToggle" title="Toggle auto refresh" style="background:transparent;color:var(--accent);border:1px solid #e6e9ef;padding:6px;border-radius:8px;cursor:pointer">Auto refresh: Off</button>
        <button id="themeToggle" title="Toggle theme">üåô</button>
        <button id="settingsBtn" title="Settings" style="background:transparent;color:var(--accent);border:1px solid #e6e9ef;padding:6px;border-radius:8px;">‚öôÔ∏è</button>
        <!-- Hidden inputs: values are edited through settings panel and persisted to localStorage -->
        <input id="containerUrl" type="url" placeholder="https://account.blob.core.windows.net/container?sv=..." style="display:none;width:420px"/>
        <input id="sas" type="text" placeholder="?sv=... (optional if included in URL)" style="display:none;width:360px"/>
      </div>
    </header>

    <div class="card">
      <div class="top-grid">
        <div class="viewer">
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
            <div class="muted">Most recent photo / video</div>
            <div style="display:flex;gap:8px;align-items:center">
              <div id="detectionBadge" class="badge" style="display:none">MANGO</div>
              <div id="photoInfo" class="muted"></div>
            </div>
          </div>
          <div class="imgwrap" id="imgwrap">
            <div class="muted">No image loaded</div>
          </div>
        </div>

        <div>
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div class="muted">Timestamps & messages</div>
            <div><button id="analyzeSelected" disabled>Analyze (vision)</button></div>
          </div>
          <div class="side-list" id="list"></div>
        </div>
      </div>

      <div class="chart-area">
        <canvas id="trendChart" height="140"></canvas>
      </div>

      <!-- add Analyze controls and results -->
      <div id="analyze-controls" style="margin-top:12px;">
        <button id="analyze-selected" class="btn">Analyze selected</button>
        <span id="analyze-status" style="margin-left:10px;"></span>
      </div>

      <!-- results -->
      <div id="analyze-result" style="margin-top:12px;">
        <div><strong>Mango likelihood:</strong> <span id="mango-likelihood">N/A</span></div>
        <div id="detection-list" style="margin-top:6px;"></div>
      </div>

      <!-- canvas overlay for boxes (position it over your preview image) -->
      <canvas id="detection-canvas" style="position:absolute; left:0; top:0; pointer-events:none; display:none;"></canvas>
    </div>
  </div>

  <!-- Settings overlay (hidden by default) -->
  <div id="settingsOverlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);align-items:center;justify-content:center;">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div><strong>Settings</strong><div class="muted">Paste your container URL or SAS token here ‚Äî values are saved locally.</div></div>
        <div><button id="closeSettings">Close</button></div>
      </div>
      <div style="display:flex;gap:8px;flex-direction:column;">
        <label class="muted">Container URL (optional, include SAS if you want)</label>
        <input id="settingsContainerUrl" type="url" style="width:100%" />
        <label class="muted">SAS token (optional, if not in URL)</label>
        <input id="settingsSas" type="text" style="width:100%" />
        <label class="muted">API Ninjas Key (will be stored on server, not in your browser)</label>
        <input id="settingsApiKey" type="password" style="width:100%" placeholder="Paste API key to save on server" />
        <label class="muted">Container/account defaults (optional)</label>
        <div style="display:flex;gap:8px;">
          <input id="settingsAccount" placeholder="account name (e.g. frutablob)" style="flex:1"/>
          <input id="settingsContainer" placeholder="container name (e.g. fruta-container2)" style="flex:1"/>
        </div>
        <div style="display:flex;justify-content:flex-end;margin-top:8px">
          <button id="saveSettings">Save</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script>
    // basic runtime state + small helpers to prevent ReferenceErrors
    let currentItems = [];
    let currentIndex = 0;

    // safe HTML escape for item names
    function escapeHtml(str){
      if(!str) return '';
      return String(str).replace(/[&<>"'`=\/]/g, function(s){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;",'/':'&#x2F;','`':'&#x60;','=':'&#x3D;'})[s]; });
    }

    // fallback fetchBlobMetadata used when code asks for blob metadata
    async function fetchBlobMetadata(name){
      // server already exposes /api/fetch_blob_content which returns blob bytes,
      // but some code expects metadata with a blob_url ‚Äî return the proxy URL here.
      return { blob_url: name ? ('/api/fetch_blob_content?name=' + encodeURIComponent(name)) : null };
    }

    // analyzeCurrent was referenced from template ‚Äî provide a safe stub that triggers the existing analyze button
    function analyzeCurrent(){
      try {
        const btn = document.getElementById('analyzeSelected');
        if(btn) {
          // prefer programmatic click if the app wired a handler
          btn.click();
          return;
        }
      } catch(e){}
      console.warn('analyzeCurrent: analyzeSelected button missing or no handler attached');
    }

    // apply persisted theme preference on load
    (function(){
      try {
        const dark = JSON.parse(localStorage.getItem('fruta.dark') || 'false');
        if(dark) document.documentElement.classList.add('dark');
        document.getElementById('themeToggle').textContent = dark ? '‚òÄÔ∏è' : 'üåô';
      } catch(e){}
    })();

    // toggle theme and persist choice
    document.getElementById('themeToggle').addEventListener('click', ()=>{
      const isDark = document.documentElement.classList.toggle('dark');
      document.getElementById('themeToggle').textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
      localStorage.setItem('fruta.dark', JSON.stringify(isDark));
    });

    // defaults (can be overridden via Settings and saved in localStorage)
    const accountEl = { account: 'frutablob', container: 'fruta-container2' };
    // Auto-refresh / polling configuration with exponential backoff
    let autoRefresh = false;
    let pollHandle = null;
    let currentPollMs = 5000;          // start at 5s for faster updates
    const basePollMs = 5000;
    const maxPollMs = 60000;           // backoff ceiling 60s
    const backoffFactor = 1.8;
    let failureCount = 0;

    // last-seen markers (prefer ETag)
    let lastSeenName = null;
    let lastSeenEtag = null;
    let lastSeenLastModified = null;

    // SSE client
    let evtSource = null;
    let sseReconnectMs = 1000;
    const sseMaxReconnectMs = 30000;
    let sseErrorCount = 0;
    const sseMaxErrors = 3;

    function startSSE(){
      if(typeof EventSource === 'undefined') return false;
      if(evtSource) return true;
      try {
        evtSource = new EventSource('/events');
        evtSource.onopen = ()=> { console.info('SSE open'); sseErrorCount = 0; sseReconnectMs = 1000; };
        evtSource.onmessage = (ev)=>{
          try {
            const msg = JSON.parse(ev.data);
            // expected message structure: { type: 'blob', name, etag, lastModified } or { type: 'list', items: [...] }
            if(msg.type === 'blob'){
              if(msg.etag && msg.etag !== lastSeenEtag || (!msg.etag && msg.lastModified !== lastSeenLastModified) || msg.name !== lastSeenName){
                console.info('SSE: new blob event', msg);
                awaitLoadLatest();
              }
            } else if(msg.type === 'list'){
              // server may emit list events without embedding items (avoid heavy payloads)
              // if items are included, pass them through; otherwise fetch latest list
              if(Array.isArray(msg.items) && msg.items.length){
                handleServerList(msg.items);
              } else {
                awaitLoadLatest();
              }
            }
          } catch(e){ console.warn('SSE parse error', e); }
        };
        evtSource.onerror = (e)=>{
          console.warn('SSE error', e);
          sseErrorCount++;
          // if errors keep happening, stop trying SSE and use polling
          if(sseErrorCount >= sseMaxErrors){
            console.warn('SSE failing repeatedly, falling back to polling');
            try { evtSource.close(); } catch(_) {}
            evtSource = null;
            startPolling();
            return;
          }
          // transient: close and schedule reconnect
          try { evtSource.close(); } catch(_) {}
          evtSource = null;
          setTimeout(()=> { sseReconnectMs = Math.min(sseMaxReconnectMs, sseReconnectMs * 1.5); startSSE(); }, sseReconnectMs);
        };
        return true;
      } catch(e){
        console.warn('SSE not available', e);
        evtSource = null;
        return false;
      }
    }

    function stopSSE(){
      if(evtSource){ try{ evtSource.close(); }catch(_){} evtSource = null; }
    }

    // Auto-follow newest image state (when true, UI will auto-load newest on list updates)
    let autoFollowLatest = true;   // start ON as requested
    let userSelected = false;      // becomes true when user clicks a specific image
    const idleMs = 20 * 60 * 1000; // 20 minutes
    let idleTimer = null;

    function updateAutoFollowButton(){
      const btn = document.getElementById('go');
      if(!btn) return;
      btn.textContent = autoFollowLatest ? 'Load latest (follow ON)' : 'Load latest (follow OFF)';
    }

    // call when user interacts to reset idle timer
    function resetIdleTimer(){
      if(idleTimer) { clearTimeout(idleTimer); idleTimer = null; }
      idleTimer = setTimeout(()=>{
        // re-enable follow if idle reached
        userSelected = false;
        autoFollowLatest = true;
        updateAutoFollowButton();
        // fetch and show latest immediately
        awaitLoadLatest();
      }, idleMs);
    }

    // attach interaction listeners to reset idle timer
    ['click','mousemove','keydown','touchstart'].forEach(ev => {
      document.addEventListener(ev, resetIdleTimer, { passive: true });
    });

    // ensure initial idle timer starts
    resetIdleTimer();

    // modify renderList to respect autoFollowLatest
    function renderList(items){
      const listEl = document.getElementById('list');
      listEl.innerHTML = '';
      items.forEach((it, idx)=>{
        const el = document.createElement('div');
        el.className = 'list-item';
        el.dataset.index = idx;
        const name = it.name || '(unknown)';
        const time = it.lastModified ? new Date(it.lastModified).toLocaleString() : '';
        el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:600">${escapeHtml(name)}</div><div class="time">${escapeHtml(time)}</div></div>`;
        el.addEventListener('click', ()=> {
          // user explicitly selected an item -> disable follow
          userSelected = true;
          autoFollowLatest = false;
          updateAutoFollowButton();
          loadItem(idx);
        });
        listEl.appendChild(el);
      });

      // If follow mode is ON and user hasn't selected a specific image, load newest (index 0)
      if(autoFollowLatest && !userSelected && items && items.length){
        // avoid overlapping calls
        loadItem(0).catch(()=>{ /* ignore */ });
      }
    }

    // update loadItem to disable follow when user manually clicks via other UI paths
    async function loadItem(index){
      if(!currentItems || index < 0 || index >= currentItems.length) return;
      currentIndex = index;
      const it = currentItems[index];

      // If this call was triggered by a user click elsewhere, ensure we set userSelected
      // (calls from follow behavior will be left as-is)
      // Note: click handlers above already set userSelected accordingly.

      let blobUrl = it.name ? ('/api/fetch_blob_content?name=' + encodeURIComponent(it.name)) : null;
      if(!blobUrl) {
        try {
          const meta = await fetchBlobMetadata(it.name);
          blobUrl = meta.blob_url || meta.blobUrl || null;
        } catch(e){
          console.warn('failed to fetch blob metadata', e);
        }
      }
      // render image element
      const wrap = document.getElementById('imgwrap');
      wrap.innerHTML = '<div class="muted">Loading image‚Ä¶</div>';
      if(!blobUrl){
        wrap.innerHTML = '<div class="muted">Image URL not available</div>';
        document.getElementById('analyzeSelected').disabled = true;
        return;
      }
      const img = document.createElement('img');
      img.alt = it.name || '';
      img.onload = ()=> {
        // run analysis automatically after image loads
        try { analyzeBlob(it).catch(()=>{}); } catch(_) {}
      };
      img.onerror = ()=> { wrap.innerHTML = '<div class="muted">Failed to load image</div>'; };
      img.src = blobUrl;
      wrap.innerHTML = '';
      wrap.appendChild(img);

      // update info and controls
      document.getElementById('photoInfo').textContent = `${it.name || ''} ${it.lastModified ? ' ¬∑ ' + new Date(it.lastModified).toLocaleString() : ''}`;
      document.getElementById('analyzeSelected').disabled = false;
      document.getElementById('detectionBadge').style.display = 'none';
    }

    // POST to server analyze endpoint and update badge based on response
    async function analyzeBlob(it){
      if(!it) return;
      try{
        const payload = it.name ? { blobName: it.name } : { blobUrl: it.url || it.blob_url };
        const resp = await fetch('/api/analyze', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if(!resp.ok){
          console.warn('analyze API returned', resp.status);
          return;
        }
        const data = await resp.json();
        // show mango badge when likelihood > 0 (adjust threshold as desired)
        const badge = document.getElementById('detectionBadge');
        const prob = Number(data.mango_likelihood || 0);
        if(prob > 0){
          badge.style.display = 'inline-block';
          badge.textContent = `MANGO ${Math.round(prob * 100)}%`;
        } else {
          badge.style.display = 'none';
        }

        // Update analyze result display
        document.getElementById('mango-likelihood').textContent = prob > 0 ? `${Math.round(prob * 100)}%` : 'N/A';
        const detectionList = document.getElementById('detection-list');
        detectionList.innerHTML = '';
        if(Array.isArray(data.detections) && data.detections.length > 0){
          data.detections.forEach(det => {
            const item = document.createElement('div');
            item.textContent = `${det.label} (${Math.round(det.confidence * 100)}%)`;
            detectionList.appendChild(item);
          });
        } else {
          detectionList.innerHTML = '<div class="muted">No detections found</div>';
        }
      }catch(e){
        console.warn('analyzeBlob error', e);
      }
    }

    // "Load latest" button should enable follow mode and immediately show newest
    document.getElementById('go').addEventListener('click', async ()=>{
      userSelected = false;
      autoFollowLatest = true;
      updateAutoFollowButton();
      awaitLoadLatest(); // loads list and renderList will open newest
    });

    // ensure button label matches initial state
    updateAutoFollowButton();

    // existing SSE / polling handlers already call awaitLoadLatest() or handleServerList()
    // ensure handleServerList uses renderList which now follows the follow flag:
    function handleServerList(items){
      if(!items || items.length === 0) return;
      const newest = items[0];
      if(newest.etag) {
        if(newest.etag !== lastSeenEtag) { lastSeenEtag = newest.etag; lastSeenName = newest.name; lastSeenLastModified = newest.lastModified; awaitLoadLatest(); }
      } else if(newest.lastModified){
        if(newest.lastModified !== lastSeenLastModified) { lastSeenLastModified = newest.lastModified; lastSeenName = newest.name; awaitLoadLatest(); }
      } else {
        if(newest.name !== lastSeenName) { lastSeenName = newest.name; awaitLoadLatest(); }
      }
    }

    // Fetch latest list from server and render (used by SSE/polling and UI)
    async function awaitLoadLatest(){
      try{
        const resp = await fetch('/api/load_latest');
        if(!resp.ok){
          console.warn('load_latest failed', resp.status);
          return;
        }
        const data = await resp.json();
        currentItems = Array.isArray(data.items) ? data.items : [];
        // server returns newest-first; ensure we respect that
        renderList(currentItems);
      }catch(e){
        console.warn('awaitLoadLatest error', e);
      }
    }

    // Simple polling fallback
    function startPolling(){
      stopPolling();
      // immediate fetch then interval
      awaitLoadLatest().catch(()=>{});
      pollHandle = setInterval(()=> { awaitLoadLatest().catch(()=>{}); }, currentPollMs);
    }
    function stopPolling(){
      if(pollHandle){ clearInterval(pollHandle); pollHandle = null; }
    }

    // Toggle auto-refresh (SSE preferred, polling fallback)
    function updateAutoRefreshToggleButton(){
      const b = document.getElementById('autoRefreshToggle');
      if(!b) return;
      b.textContent = autoRefresh ? 'Auto refresh: On' : 'Auto refresh: Off';
    }

    function toggleAutoRefresh(forceState){
      autoRefresh = (typeof forceState === 'boolean') ? forceState : !autoRefresh;
      updateAutoRefreshToggleButton();
      if(autoRefresh){
        // try SSE first, if not available start polling
        if(!startSSE()){
          startPolling();
        } else {
          // ensure we have current data
          awaitLoadLatest().catch(()=>{});
        }
      } else {
        stopSSE();
        stopPolling();
      }
    }

    // bind the UI toggle button
    const autoBtn = document.getElementById('autoRefreshToggle');
    if(autoBtn) autoBtn.addEventListener('click', ()=> toggleAutoRefresh());
    // ensure label initially correct
    updateAutoRefreshToggleButton();

    // initial action: attempt to load latest on first open and start refresh
    awaitLoadLatest();
    toggleAutoRefresh(true);
  </script>
</body>
</html>